## Процесс
> То что выполняется в текущий момент и преобразует входящие данные в исходящие, совокупность кода и ресуросв.

Создается только путем копирования уже существующего процесса (fork).
Процесс клонируется полностью, и только после пересоздания в клонированном процесе происходит замещение исполняемого кода на новый.
Т.е. при запуске кода происходит следующая последовательность:
* fork второго дочернего процесса (потомок) из первичного (родитель)
* переписание (загрузка) кода в потомке (системный вызов **exec**)
* исполнние потомка
* завершение потомка (системный вызов **exit**) и возврат в родитель
* состояние **зомби** (не занимает ресурсов, просто строка с идентификатором в таблице процессов). Считается в общем количестве процессов и сказывается на ограничении количества процессов для пользователя. Большое количество говорит о том, что либо система не справляется с обработкой процессов, либо в родительском процессе баг. когда отсутствует вызов wait, считывающий коды возврата потомков. В случае бага единственный способ завершить зомби-процессы - отцепить их от родительского процесса (сделать сиротами) и прикрепить к процессу Init, после чего он считает код возврата и завершит процесс.
* считывание кода возврата (вызов **wait**) (считать код возврата может только тот процесс (родитель), который запустил второй процесс (потомка))
* уничтожение потомка (удаление из ОС)
* завершение или продолжение работы родителя

Все процессы имеют родителя. Исключение - два системных процесса.
PID - идентификатор процесса
PPID - идентификатор родительского прорцесса
Init - первичный процесс в пространстве пользователя (PID = 1, PPID = 0). Возникает из ядра ОС в момент ее старта.
Kthreadd - первичный процесс в пространстве ядра (PID = 2, PPID = 0)

Процесс - совокупность файлов и данных (все есть файл).
```
# все процессы создаются и хранят свои данные тут
/proc/<pid>
```
> Просмотреть процессы могут любые пользователи.
>
> Управлять тпроцессом может либо владелец, либо root.
>
> Сменить владельца прорцесса невозможно.

Владельцем процесса является тот кто является владельцем каталога /proc/<pid>.

## Демон
Сервис, не воспринимающий сигналы ввода от пользователя (не работающая с терминалом).
Воспринимает только спец сигналы ОС.

## Kill
```
kill <-signal> pid
```
<-signal> может определяться константами с префиксом SIG*, либо в числовом виде. Всего их 28.

Полезные варианты:
* SIGINT-2 - аналог Ctrl-C
* SIGTERM-15 - по умоляанию сингнал завершения kill
* SIGKILL-9 - безусловное завершение

## Top
s+кол-во сек - интервал обновления
1 - показываем имеющиеся ядра процессора и распределение нагрузки по ним (3 строка шапки)

### Информация в шапке
* uptime
* load average (min/5 min/15min) - кол-во процессов в очереди на ожидание ресурсов (нормальное значение должно быть меньше либо равно кол-ву ядер процессора). Однако в очередь встают не только процессы, ожидающие процессорного времени, но и ожидающие ресурсы **ввода-вывода**(напр сетевой ресурс и т.п.. такой процесс получает статус D и его нельзя завершить). Потому очередь может принимать астрономические значения в случае задержек на таких ресурсах, что не говорит о загруженности процессора.

### Строка CPU
* us - пространство пользователя
* sy - системное пространство (сетевые устройства, драйверы etc)
* ni - атавизм, доля процессов с пониженным приоритетом
* id - idle, процент простоя CPU
* wa - wait, сколько времени потрачено на общение с устройствами ввода-вывода (даже 5-10% будут очень существенноо влиять на производительносьть)
* hi - hardware interaption, сколько ресурсов потрачено на аппаратные прерывания (прицеплено какое-то странное или неправильно рабюотающее устройство)
* si - sofware interaption, программные прерывания (это может быть какой-то софт, работающий в режиме раздачи разделенных ресурсов, напр торрент-клиент)
* st - stolen, сколько времени было заимствовано хостовой машиной (актуально не для всех гипервизоров. напр актуально для KVM, не еактуально для Hiper-V)

Маленький wa и большой load average - много процессов в статусе D.

Большой wa и большой load average - узкое место - устройства IO (сеть, диск).

Большой wa и маленький load average и idle близок к нулю и us+si в сумме дают почти 100% - проблема с производительностью процессора.
















