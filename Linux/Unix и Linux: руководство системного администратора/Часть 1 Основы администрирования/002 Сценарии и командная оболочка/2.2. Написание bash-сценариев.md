Когда окажется, что ваш bash-сценарий превысил в объеме **сотню строк или вам потребовались средства, которыми bash не обладает**, это будет означать, что настало время переходить к языку Perl или Python.

Сценарий для оболочки bash может состоять только из последовательности командных строк.

следующий сценарий helloworld просто выполняет команду echo
```
#!/bin/bash
echo "Hello, world!"
```

Для того чтобы подготовить этот файл к выполнению, достаточно установить его бит, “отвечающий” за выполнение (см. раздел 6.5).
```
$ chmod +х helloworld
$ ./helloworld3
```

> Если ваша оболочка понимает команду helloworld без префикса ./, это означает, что в вашем пути поиска указан текущий каталог (.). И это плохо, поскольку дает другим пользователям возможность устраивать для вас “ловушки” в надежде, что вы будете пытаться выполнить определенные команды при переходе к каталогу, в котором они имеют доступ для записи.

Можно также непосредственно запустить (активизировать) оболочку в качестве интерпретатора сценария.
```
$ bash helloworld
$ source helloworld
```
**Первая команда выполнит** сценарий helloworld в новом экземпляре оболочки bash, а **вторая — заставит вашу начальную оболочку прочитать содержимое файла**, а затем выполнить его. Второй вариант полезен в случае, когда сценарий устанавливает переменные среды или выполняет другие операции настройки, применимые только к текущей оболочке. Обычно этот вариант используется при написании сценариев, **включающих содержимое файла конфигурации**, написанного в виде ряда присваиваний значений bash-переменным.

> Синонимом для команды source служит команда “с точкой” (dot-команда), например . helloworld.

В мире UNIX и Linux признак того, может ли файл быть выполнен (и если да, то кем), содержится в специальных битах полномочий. При желании вы можете наделить свои bash-сценарии суффиксом .sh, который бы напоминал вам об их типе, но тогда при выполнении соответствующей команды вам придется вводить суффикс .sh, поскольку **UNIX не интерпретирует расширения специальным образом**.

#### От команд к сценариям

Предположим у вас есть журналы регистрации, именованные с суффиксами .log и .LOG и разбросанные по всей иерархической системе каталогов. Допустим, что вы хотите изменить эти суффиксы, приведя их к “прописному” виду. Прежде всего, попытаемся отыскать все эти файлы.
```
$ find . -name '*log'
.do-not-touch/important.log
admin.com-log/
foo.log
genius/spew.log
leather_flog
```

похоже на то, что нам надо включить в шаблон точку и игнорировать при поиске каталоги. Нажмите комбинацию клавиш <Ctrl+P>, чтобы вернуть команду в командную строку, а затем модифицируйте ее.
```
$ find .-type f -name '*.log'
.do-not-touch/important.log
foo.log
```

Попробуем сгенерировать несколько новых имен.
```
$ find . -type f -name '*.log ' I grep -v .do-not-touch | while read fname
> do
> echo mv $ fname $ {fname/. log/. LOG/}
> done
mv foo.log foo.LOG
mv genius/spew.log genius/spew.LOG
```

Нажав комбинацию клавиш <Ctrl+P>, мы обнаруживаем, что оболочка bash заботливо свернула наш мини-сценарий в одну-единственную строку. К этой “уплотненной” командной строке мы просто добавляем канал, передающий наши выходные данные команде bash -х.
```
$ find . -type f -name '*.log ' I grep -v .do-not-touch | while read fname;
do echo mv $fname $ {fname/. log/. LOG/}; done | bash -x
+ mv foo.log foo.LOG
+ mv genius/spew.log genius/spew.LOG
```

> Ключ -x команды bash обеспечивает вывод каждой команды перед ее выполнением.

> Встроенная в bash **команда fc** по своему действию во многом аналогична нажатию комбинации клавиш <Ctrl+P>, но вместо возврата последней команды в командную строку она передает команду в заданный вами редактор.






