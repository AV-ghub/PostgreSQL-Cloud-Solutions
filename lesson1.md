Работа с уровнями изоляции транзакции в PostgreSQL
========================

Создать новый проект в Google Cloud Platform, Яндекс облако или на любых ВМ, например postgres2023-, где yyyymmdd год, месяц и день вашего рождения (имя проекта должно быть уникально на уровне GCP)
-------------------------

Создаем проект в ЯО: postgres2023-19720207.
Создаем каталог и сервис Compute Cloud.

Далее создать инстанс виртуальной машины Compute Engine с дефолтными параметрами - 1-2 ядра, 2-4Гб памяти, любой линукс, на курсе Ubuntu 100%
-------------------------

Создаем виртуальныю машину.

    Идентификатор: epdkuglh8pcn3hf97gue
    Имя: otus-db-pg-vm-1
    Дата создания: 28.04.2023, в 19:20
    Внутренний FQDN: otus-db-pg-vm-1.ru-central1.internal
    Зона доступности: ru-central1-b
    Сервисный аккаунт: otus

Параметры.

    Платформа: Intel Ice Lake
    Гарантированная доля vCPU: 100%
    vCPU: 2
    RAM: 4 ГБ
    Объём дискового пространства: 20 ГБ

Добавить свой ssh ключ в GCE metadata
-------------------------

Ключ сгенерен с хостовой Win машины через PuTTY (pageant.exe) и внедрен в VM на этапе ее создания.
Найти в Яндексе реестр ключей не удалось.
Соответственно отредактировать (удалить/добавить) ключи по всей видимости нельзя.
Ключ обнаружен в стандартном каталоге Ubunta.
Скорее всего сервис просто пробрасывает первый ключ туда автоматом в целях первичного коннекта, дальше крутитесь сами.
Но возможно плохо искал.

Зайти удаленным ssh (первая сессия), не забывайте про ssh-add
-------------------------

С PuTTY проброс происходит без проблем, цепляет ключ и идентифицирует.

Поставить PostgreSQL из пакетов apt install
-------------------------

По умоляанию ставится 14 версия.
15 версия со скрипта поставилась без проблем.

Зайти вторым ssh (вторая сессия). Запустить везде psql из под пользователя postgres. Выключить auto commit
-------------------------

    postgres=*# \set AUTOCOMMIT off
    postgres=*# \echo :AUTOCOMMIT
    off

Cделать в первой сессии новую таблицу и наполнить ее данными
-------------------------
    create table persons(id serial, first_name text, second_name text);
    insert into persons(first_name, second_name) values('ivan', 'ivanov');
    insert into persons(first_name, second_name) values('petr', 'petrov');
    commit;

Посмотреть текущий уровень изоляции
-------------------------

    postgres=*# show transaction isolation level;
    transaction_isolation
    -----------------------
    read committed`

## Начать новую транзакцию в обоих сессиях с дефолтным (не меняя) уровнем изоляции. В первой сессии добавить новую запись. insert into persons(first_name, second_name) values('sergey', 'sergeev'); сделать select * from persons во второй сессии. видите ли вы новую запись и если да то почему?

Нет. В обеих сессиях у нас transaction_isolation = read committed, а мы еще пока не закомитили транзакцию в первой.

## Завершить первую транзакцию - commit; Сделать select * from persons во второй сессии. Видите ли вы новую запись и если да то почему?

Да. Мы закомитили транзакцию в первой сессии и соотв теперь можем увидеть ее во второй с уровнем read committed.

## Завершите транзакцию во второй сессии. Начать новые но уже repeatable read транзакции - set transaction isolation level repeatable read; В первой сессии добавить новую запись insert into persons(first_name, second_name) values('sveta', 'svetova'); Сделать select * from persons во второй сессии. Видите ли вы новую запись и если да то почему?

Нет. Транзакция в первой сессии не завершена, и мы не можем увидеть ее даже с дефолтным уровнем, тем более с repeatable read.

## Завершить первую транзакцию - commit; Сделать select * from persons во второй сессии. Видите ли вы новую запись и если да то почему?

Нет. Потому что в отличие от дефолтного уровня read committed, мы продекларировали повторяющееся чтение и соотв в пределах своей транзакции видим только взятый в начале нашей транзакции снэпшот.
Внешние транзакции не попадают в нашу зону видимости.

## Завершить вторую транзакцию. Сделать select * from persons во второй сессии. Видите ли вы новую запись и если да то почему?

Да. Мы завершили транзакцию, а значит вышли из зоны видимости repeatable read и перешли на дефолтный уровень read committed, с которого видим все транзакции, завершенные любыми процессами.
